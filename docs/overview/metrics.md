---
id: overview_metrics
title: "Metrics"
---
```scala mdoc:silent
import java.net.InetSocketAddress
import uzhttp._
import uzhttp.server.Server

import zio._
import zio.duration._
import zio.console._

import zio.zmx.metrics._
import zio.zmx.MetricsConfigDataModel
```
# Metrics

ZMX allows the instrumentation of ZIO based applications with some extensions to the well known ZIO DSL. Using the DSL generates metrics events which will be processed 
by a reporting backend that is registered as a layer within the application. Currently, reporting to Statsd and Prometheus is supported. It is important to node that 
switching from one reporting backend to another does not require any code changes to the instrumented app. 

## The ZMX metrics DSL 

The ZMX metrics DSL is defined within the `ZMetrics` object and offers methods to manipulate all of the known metrics. Whenever it makes sense, we have also included 
extensions to the ZIO object to make metric capturing more intuitive.

```scala mdoc:silent
trait InstrumentedSample {

  def doSomething    = ZMetrics.count("myCounter")(ZIO.succeed(print(".")))
  def doSomething2   = ZIO.succeed(print(".")).counted("myCounter2")
  def countSomething = ZIO.foreach_(1.to(100))(_ => doSomething2.zip(doSomething))

  def program: ZIO[ZEnv with ZMetrics, Nothing, ExitCode] = for {
    _ <- countSomething.absorbWith(_ => new Exception("Boom")).orDie
  } yield ExitCode.success
}
```

In the example above `doSomething` and `doSomething2` both instrument a plain ZIO effect and count the number of executions of that effect. Note, that at this point 
we have not specified how the count should be processed. 

## The ZMX StatsD reporter

To run the instrumentation example above reporting to statsd, we have to inject a statsd reporter with a proper configuration. The important piece in the code 
below is the host and the port, which is the UDP adress of a statsd collector. 

```scala mdoc:silent
object StatsdInstrumentedApp extends zio.App with InstrumentedSample {

  private val config = MetricsConfigDataModel.MetricsConfig(
    maximumSize = 1024,
    bufferSize = 1024,
    timeout = 10.seconds,
    pollRate = 1.second,
    host = Some("localhost"),
    port = Some(8125)
  )

  override def run(args: List[String]): URIO[ZEnv, ExitCode] =
    program.provideCustomLayer(statsd(config))
}
```

Whenever something is counted, a statsd datagram is sent to the collector and all further processing will be done within the StatsD environment. 

## The ZMX Prometheus reporter 

In order to run the same example reporting to Prometheus, we need to plugin the Prometheus Reporter and provide a HTTP endpoint where the Prometheus agent can 
poll the collected metrics on a regular basis. 

```scala mdoc:silent
object PrometheusInstrumentedApp extends zio.App with InstrumentedSample {

  private val bindHost = "127.0.0.1"
  private val bindPort = 8080

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =
    (for {
      svc <- ZIO.service[ZMetrics.Service]
      _   <- Server
               .builder(new InetSocketAddress(bindHost, bindPort))
               .handleSome {
                 case req if req.uri.getPath() == "/"      =>
                   ZIO.succeed(Response.html("<html><title>Simple Server</title><a href=\"/metrics\">Metrics</a></html>"))
                 case req if req.uri.getPath == "/metrics" =>
                   svc.report.map(r => Response.plain(r))
               }
               .serve
               .use(s => s.awaitShutdown)
               .fork
      _   <- putStrLn("Press Any Key")
      _   <- program.fork
      f   <- getStrLn.fork
      _   <- f.join
    } yield ExitCode.success).provideCustomLayer(prometheus).orDie
}
```

Most of the code above is boilerplate code to provide a very simple HTTP server. The actual metrics document for Prometheus is generated by calling `svc.report` and 
map the outcome into a HTTP Response. 

For now we have made the decision not to bundle a specific HTTP implementation with ZMX, but just provide an example within the test code. So, users can use the example above to see how they can retrieve the metrics document and serve with the HTTP server of their choice. 
